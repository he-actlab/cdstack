# Generated from /Users/seankinzer/ACTLab/cmlang/cmlang.code/compiler/CMLang/CMLang.g4 by ANTLR 4.7
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3E")
        buf.write("\u01b4\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\3\2\3\2\3\2")
        buf.write("\5\2v\n\2\3\3\3\3\3\4\3\4\3\5\3\5\3\5\3\6\6\6\u0080\n")
        buf.write("\6\r\6\16\6\u0081\3\7\3\7\3\7\3\7\3\7\3\b\3\b\5\b\u008b")
        buf.write("\n\b\3\b\3\b\3\t\3\t\3\t\7\t\u0092\n\t\f\t\16\t\u0095")
        buf.write("\13\t\3\n\3\n\5\n\u0099\n\n\3\13\3\13\3\f\3\f\3\f\3\f")
        buf.write("\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\6\f\u00a9\n\f\r\f\16")
        buf.write("\f\u00aa\5\f\u00ad\n\f\3\r\3\r\3\r\5\r\u00b2\n\r\3\16")
        buf.write("\3\16\3\17\3\17\3\20\3\20\3\20\3\20\3\21\6\21\u00bd\n")
        buf.write("\21\r\21\16\21\u00be\3\22\3\22\3\22\5\22\u00c4\n\22\3")
        buf.write("\23\3\23\3\23\3\23\3\23\3\23\3\23\5\23\u00cd\n\23\3\23")
        buf.write("\3\23\3\23\3\23\3\23\5\23\u00d4\n\23\3\24\3\24\5\24\u00d8")
        buf.write("\n\24\3\25\3\25\3\25\3\25\3\26\3\26\3\26\3\27\3\27\3\30")
        buf.write("\3\30\3\31\3\31\3\31\3\31\3\31\3\31\3\32\3\32\3\32\3\33")
        buf.write("\3\33\3\33\5\33\u00f1\n\33\3\34\3\34\3\34\3\35\3\35\3")
        buf.write("\36\3\36\3\36\3\37\3\37\3\37\3\37\3\37\3\37\5\37\u0101")
        buf.write("\n\37\3 \3 \3!\3!\3!\5!\u0108\n!\3\"\3\"\3\"\3\"\3\"\3")
        buf.write("\"\3\"\3#\3#\3#\5#\u0114\n#\3#\3#\3#\3$\3$\3$\5$\u011c")
        buf.write("\n$\3%\3%\3%\5%\u0121\n%\3&\3&\3&\3\'\3\'\3\'\5\'\u0129")
        buf.write("\n\'\3(\3(\3(\3)\3)\3)\5)\u0131\n)\3*\3*\3+\3+\3+\5+\u0138")
        buf.write("\n+\3+\3+\3,\3,\3-\3-\3-\3-\3-\3-\3.\3.\3/\3/\3\60\3\60")
        buf.write("\3\61\3\61\3\61\3\61\7\61\u014e\n\61\f\61\16\61\u0151")
        buf.write("\13\61\3\62\3\62\3\62\3\62\7\62\u0157\n\62\f\62\16\62")
        buf.write("\u015a\13\62\3\63\3\63\3\63\3\63\7\63\u0160\n\63\f\63")
        buf.write("\16\63\u0163\13\63\3\64\3\64\3\64\3\64\7\64\u0169\n\64")
        buf.write("\f\64\16\64\u016c\13\64\3\65\3\65\3\65\3\65\5\65\u0172")
        buf.write("\n\65\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66")
        buf.write("\5\66\u017e\n\66\3\67\3\67\3\67\6\67\u0183\n\67\r\67\16")
        buf.write("\67\u0184\3\67\3\67\3\67\3\67\3\67\3\67\3\67\3\67\3\67")
        buf.write("\3\67\5\67\u0191\n\67\38\38\38\38\38\38\38\38\38\58\u019c")
        buf.write("\n8\38\38\58\u01a0\n8\38\38\58\u01a4\n8\38\38\58\u01a8")
        buf.write("\n8\39\39\39\39\39\39\39\39\59\u01b2\n9\39\2\2:\2\4\6")
        buf.write("\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\66")
        buf.write("8:<>@BDFHJLNPRTVXZ\\^`bdfhjlnp\2\13\3\2@C\5\2\3\5  \"")
        buf.write("\"\4\2\7\t\13\13\3\2\f\16\3\2\36\37\4\2 $&\61\3\2\27\33")
        buf.write("\3\2\24\25\4\2\26\26\34\34\2\u01a8\2u\3\2\2\2\4w\3\2\2")
        buf.write("\2\6y\3\2\2\2\b{\3\2\2\2\n\177\3\2\2\2\f\u0083\3\2\2\2")
        buf.write("\16\u0088\3\2\2\2\20\u008e\3\2\2\2\22\u0098\3\2\2\2\24")
        buf.write("\u009a\3\2\2\2\26\u00ac\3\2\2\2\30\u00b1\3\2\2\2\32\u00b3")
        buf.write("\3\2\2\2\34\u00b5\3\2\2\2\36\u00b7\3\2\2\2 \u00bc\3\2")
        buf.write("\2\2\"\u00c3\3\2\2\2$\u00d3\3\2\2\2&\u00d7\3\2\2\2(\u00d9")
        buf.write("\3\2\2\2*\u00dd\3\2\2\2,\u00e0\3\2\2\2.\u00e2\3\2\2\2")
        buf.write("\60\u00e4\3\2\2\2\62\u00ea\3\2\2\2\64\u00f0\3\2\2\2\66")
        buf.write("\u00f2\3\2\2\28\u00f5\3\2\2\2:\u00f7\3\2\2\2<\u0100\3")
        buf.write("\2\2\2>\u0102\3\2\2\2@\u0107\3\2\2\2B\u0109\3\2\2\2D\u0110")
        buf.write("\3\2\2\2F\u011b\3\2\2\2H\u0120\3\2\2\2J\u0122\3\2\2\2")
        buf.write("L\u0128\3\2\2\2N\u012a\3\2\2\2P\u0130\3\2\2\2R\u0132\3")
        buf.write("\2\2\2T\u0134\3\2\2\2V\u013b\3\2\2\2X\u013d\3\2\2\2Z\u0143")
        buf.write("\3\2\2\2\\\u0145\3\2\2\2^\u0147\3\2\2\2`\u0149\3\2\2\2")
        buf.write("b\u0152\3\2\2\2d\u015b\3\2\2\2f\u0164\3\2\2\2h\u0171\3")
        buf.write("\2\2\2j\u017d\3\2\2\2l\u0190\3\2\2\2n\u01a7\3\2\2\2p\u01b1")
        buf.write("\3\2\2\2rv\5\4\3\2sv\7D\2\2tv\7E\2\2ur\3\2\2\2us\3\2\2")
        buf.write("\2ut\3\2\2\2v\3\3\2\2\2wx\t\2\2\2x\5\3\2\2\2yz\t\3\2\2")
        buf.write("z\7\3\2\2\2{|\5\n\6\2|}\7\2\2\3}\t\3\2\2\2~\u0080\5\f")
        buf.write("\7\2\177~\3\2\2\2\u0080\u0081\3\2\2\2\u0081\177\3\2\2")
        buf.write("\2\u0081\u0082\3\2\2\2\u0082\13\3\2\2\2\u0083\u0084\5")
        buf.write("\34\17\2\u0084\u0085\7<\2\2\u0085\u0086\5\16\b\2\u0086")
        buf.write("\u0087\5\36\20\2\u0087\r\3\2\2\2\u0088\u008a\78\2\2\u0089")
        buf.write("\u008b\5\20\t\2\u008a\u0089\3\2\2\2\u008a\u008b\3\2\2")
        buf.write("\2\u008b\u008c\3\2\2\2\u008c\u008d\79\2\2\u008d\17\3\2")
        buf.write("\2\2\u008e\u0093\5\26\f\2\u008f\u0090\7:\2\2\u0090\u0092")
        buf.write("\5\26\f\2\u0091\u008f\3\2\2\2\u0092\u0095\3\2\2\2\u0093")
        buf.write("\u0091\3\2\2\2\u0093\u0094\3\2\2\2\u0094\21\3\2\2\2\u0095")
        buf.write("\u0093\3\2\2\2\u0096\u0099\7?\2\2\u0097\u0099\5\2\2\2")
        buf.write("\u0098\u0096\3\2\2\2\u0098\u0097\3\2\2\2\u0099\23\3\2")
        buf.write("\2\2\u009a\u009b\7<\2\2\u009b\25\3\2\2\2\u009c\u009d\5")
        buf.write("\32\16\2\u009d\u009e\5\6\4\2\u009e\u009f\7<\2\2\u009f")
        buf.write("\u00a0\5\30\r\2\u00a0\u00ad\3\2\2\2\u00a1\u00a2\5\32\16")
        buf.write("\2\u00a2\u00a3\5\6\4\2\u00a3\u00a8\7<\2\2\u00a4\u00a5")
        buf.write("\7\64\2\2\u00a5\u00a6\5\24\13\2\u00a6\u00a7\7\65\2\2\u00a7")
        buf.write("\u00a9\3\2\2\2\u00a8\u00a4\3\2\2\2\u00a9\u00aa\3\2\2\2")
        buf.write("\u00aa\u00a8\3\2\2\2\u00aa\u00ab\3\2\2\2\u00ab\u00ad\3")
        buf.write("\2\2\2\u00ac\u009c\3\2\2\2\u00ac\u00a1\3\2\2\2\u00ad\27")
        buf.write("\3\2\2\2\u00ae\u00af\7;\2\2\u00af\u00b2\5\22\n\2\u00b0")
        buf.write("\u00b2\3\2\2\2\u00b1\u00ae\3\2\2\2\u00b1\u00b0\3\2\2\2")
        buf.write("\u00b2\31\3\2\2\2\u00b3\u00b4\t\4\2\2\u00b4\33\3\2\2\2")
        buf.write("\u00b5\u00b6\t\5\2\2\u00b6\35\3\2\2\2\u00b7\u00b8\7\67")
        buf.write("\2\2\u00b8\u00b9\5 \21\2\u00b9\u00ba\7\66\2\2\u00ba\37")
        buf.write("\3\2\2\2\u00bb\u00bd\5\"\22\2\u00bc\u00bb\3\2\2\2\u00bd")
        buf.write("\u00be\3\2\2\2\u00be\u00bc\3\2\2\2\u00be\u00bf\3\2\2\2")
        buf.write("\u00bf!\3\2\2\2\u00c0\u00c4\5$\23\2\u00c1\u00c4\5D#\2")
        buf.write("\u00c2\u00c4\5n8\2\u00c3\u00c0\3\2\2\2\u00c3\u00c1\3\2")
        buf.write("\2\2\u00c3\u00c2\3\2\2\2\u00c4#\3\2\2\2\u00c5\u00c6\5")
        buf.write("&\24\2\u00c6\u00c7\7\62\2\2\u00c7\u00d4\3\2\2\2\u00c8")
        buf.write("\u00c9\58\35\2\u00c9\u00cc\7;\2\2\u00ca\u00cd\5`\61\2")
        buf.write("\u00cb\u00cd\5X-\2\u00cc\u00ca\3\2\2\2\u00cc\u00cb\3\2")
        buf.write("\2\2\u00cd\u00ce\3\2\2\2\u00ce\u00cf\7\62\2\2\u00cf\u00d4")
        buf.write("\3\2\2\2\u00d0\u00d1\5T+\2\u00d1\u00d2\7\62\2\2\u00d2")
        buf.write("\u00d4\3\2\2\2\u00d3\u00c5\3\2\2\2\u00d3\u00c8\3\2\2\2")
        buf.write("\u00d3\u00d0\3\2\2\2\u00d4%\3\2\2\2\u00d5\u00d8\5(\25")
        buf.write("\2\u00d6\u00d8\5*\26\2\u00d7\u00d5\3\2\2\2\u00d7\u00d6")
        buf.write("\3\2\2\2\u00d8\'\3\2\2\2\u00d9\u00da\7\n\2\2\u00da\u00db")
        buf.write("\5\6\4\2\u00db\u00dc\5\62\32\2\u00dc)\3\2\2\2\u00dd\u00de")
        buf.write("\5.\30\2\u00de\u00df\5B\"\2\u00df+\3\2\2\2\u00e0\u00e1")
        buf.write("\7\35\2\2\u00e1-\3\2\2\2\u00e2\u00e3\7\21\2\2\u00e3/\3")
        buf.write("\2\2\2\u00e4\u00e5\7<\2\2\u00e5\u00e6\7\64\2\2\u00e6\u00e7")
        buf.write("\5> \2\u00e7\u00e8\7\65\2\2\u00e8\u00e9\5<\37\2\u00e9")
        buf.write("\61\3\2\2\2\u00ea\u00eb\5\60\31\2\u00eb\u00ec\5\64\33")
        buf.write("\2\u00ec\63\3\2\2\2\u00ed\u00ee\7:\2\2\u00ee\u00f1\5\62")
        buf.write("\32\2\u00ef\u00f1\3\2\2\2\u00f0\u00ed\3\2\2\2\u00f0\u00ef")
        buf.write("\3\2\2\2\u00f1\65\3\2\2\2\u00f2\u00f3\58\35\2\u00f3\u00f4")
        buf.write("\5@!\2\u00f4\67\3\2\2\2\u00f5\u00f6\5:\36\2\u00f69\3\2")
        buf.write("\2\2\u00f7\u00f8\7<\2\2\u00f8\u00f9\5<\37\2\u00f9;\3\2")
        buf.write("\2\2\u00fa\u00fb\7\64\2\2\u00fb\u00fc\5> \2\u00fc\u00fd")
        buf.write("\7\65\2\2\u00fd\u00fe\5<\37\2\u00fe\u0101\3\2\2\2\u00ff")
        buf.write("\u0101\3\2\2\2\u0100\u00fa\3\2\2\2\u0100\u00ff\3\2\2\2")
        buf.write("\u0101=\3\2\2\2\u0102\u0103\5`\61\2\u0103?\3\2\2\2\u0104")
        buf.write("\u0105\7:\2\2\u0105\u0108\5\66\34\2\u0106\u0108\3\2\2")
        buf.write("\2\u0107\u0104\3\2\2\2\u0107\u0106\3\2\2\2\u0108A\3\2")
        buf.write("\2\2\u0109\u010a\7<\2\2\u010a\u010b\7\64\2\2\u010b\u010c")
        buf.write("\5`\61\2\u010c\u010d\7\63\2\2\u010d\u010e\5`\61\2\u010e")
        buf.write("\u010f\7\65\2\2\u010fC\3\2\2\2\u0110\u0111\7<\2\2\u0111")
        buf.write("\u0113\78\2\2\u0112\u0114\5J&\2\u0113\u0112\3\2\2\2\u0113")
        buf.write("\u0114\3\2\2\2\u0114\u0115\3\2\2\2\u0115\u0116\79\2\2")
        buf.write("\u0116\u0117\7\62\2\2\u0117E\3\2\2\2\u0118\u011c\7<\2")
        buf.write("\2\u0119\u011c\5\2\2\2\u011a\u011c\7?\2\2\u011b\u0118")
        buf.write("\3\2\2\2\u011b\u0119\3\2\2\2\u011b\u011a\3\2\2\2\u011c")
        buf.write("G\3\2\2\2\u011d\u0121\7<\2\2\u011e\u0121\5\2\2\2\u011f")
        buf.write("\u0121\7?\2\2\u0120\u011d\3\2\2\2\u0120\u011e\3\2\2\2")
        buf.write("\u0120\u011f\3\2\2\2\u0121I\3\2\2\2\u0122\u0123\5H%\2")
        buf.write("\u0123\u0124\5L\'\2\u0124K\3\2\2\2\u0125\u0126\7:\2\2")
        buf.write("\u0126\u0129\5J&\2\u0127\u0129\3\2\2\2\u0128\u0125\3\2")
        buf.write("\2\2\u0128\u0127\3\2\2\2\u0129M\3\2\2\2\u012a\u012b\5")
        buf.write("F$\2\u012b\u012c\5P)\2\u012cO\3\2\2\2\u012d\u012e\7:\2")
        buf.write("\2\u012e\u0131\5N(\2\u012f\u0131\3\2\2\2\u0130\u012d\3")
        buf.write("\2\2\2\u0130\u012f\3\2\2\2\u0131Q\3\2\2\2\u0132\u0133")
        buf.write("\t\6\2\2\u0133S\3\2\2\2\u0134\u0135\5R*\2\u0135\u0137")
        buf.write("\78\2\2\u0136\u0138\5N(\2\u0137\u0136\3\2\2\2\u0137\u0138")
        buf.write("\3\2\2\2\u0138\u0139\3\2\2\2\u0139\u013a\79\2\2\u013a")
        buf.write("U\3\2\2\2\u013b\u013c\t\7\2\2\u013cW\3\2\2\2\u013d\u013e")
        buf.write("\5`\61\2\u013e\u013f\7\6\2\2\u013f\u0140\5`\61\2\u0140")
        buf.write("\u0141\7\63\2\2\u0141\u0142\5`\61\2\u0142Y\3\2\2\2\u0143")
        buf.write("\u0144\t\b\2\2\u0144[\3\2\2\2\u0145\u0146\t\t\2\2\u0146")
        buf.write("]\3\2\2\2\u0147\u0148\t\n\2\2\u0148_\3\2\2\2\u0149\u014f")
        buf.write("\5b\62\2\u014a\u014b\5Z.\2\u014b\u014c\5b\62\2\u014c\u014e")
        buf.write("\3\2\2\2\u014d\u014a\3\2\2\2\u014e\u0151\3\2\2\2\u014f")
        buf.write("\u014d\3\2\2\2\u014f\u0150\3\2\2\2\u0150a\3\2\2\2\u0151")
        buf.write("\u014f\3\2\2\2\u0152\u0158\5d\63\2\u0153\u0154\5\\/\2")
        buf.write("\u0154\u0155\5d\63\2\u0155\u0157\3\2\2\2\u0156\u0153\3")
        buf.write("\2\2\2\u0157\u015a\3\2\2\2\u0158\u0156\3\2\2\2\u0158\u0159")
        buf.write("\3\2\2\2\u0159c\3\2\2\2\u015a\u0158\3\2\2\2\u015b\u0161")
        buf.write("\5f\64\2\u015c\u015d\5^\60\2\u015d\u015e\5f\64\2\u015e")
        buf.write("\u0160\3\2\2\2\u015f\u015c\3\2\2\2\u0160\u0163\3\2\2\2")
        buf.write("\u0161\u015f\3\2\2\2\u0161\u0162\3\2\2\2\u0162e\3\2\2")
        buf.write("\2\u0163\u0161\3\2\2\2\u0164\u016a\5h\65\2\u0165\u0166")
        buf.write("\5,\27\2\u0166\u0167\5h\65\2\u0167\u0169\3\2\2\2\u0168")
        buf.write("\u0165\3\2\2\2\u0169\u016c\3\2\2\2\u016a\u0168\3\2\2\2")
        buf.write("\u016a\u016b\3\2\2\2\u016bg\3\2\2\2\u016c\u016a\3\2\2")
        buf.write("\2\u016d\u016e\5\\/\2\u016e\u016f\5h\65\2\u016f\u0172")
        buf.write("\3\2\2\2\u0170\u0172\5j\66\2\u0171\u016d\3\2\2\2\u0171")
        buf.write("\u0170\3\2\2\2\u0172i\3\2\2\2\u0173\u017e\5\2\2\2\u0174")
        buf.write("\u017e\58\35\2\u0175\u017e\5T+\2\u0176\u0177\5V,\2\u0177")
        buf.write("\u0178\5l\67\2\u0178\u017e\3\2\2\2\u0179\u017a\78\2\2")
        buf.write("\u017a\u017b\5`\61\2\u017b\u017c\79\2\2\u017c\u017e\3")
        buf.write("\2\2\2\u017d\u0173\3\2\2\2\u017d\u0174\3\2\2\2\u017d\u0175")
        buf.write("\3\2\2\2\u017d\u0176\3\2\2\2\u017d\u0179\3\2\2\2\u017e")
        buf.write("k\3\2\2\2\u017f\u0180\7\64\2\2\u0180\u0181\7<\2\2\u0181")
        buf.write("\u0183\7\65\2\2\u0182\u017f\3\2\2\2\u0183\u0184\3\2\2")
        buf.write("\2\u0184\u0182\3\2\2\2\u0184\u0185\3\2\2\2\u0185\u0186")
        buf.write("\3\2\2\2\u0186\u0187\78\2\2\u0187\u0188\5`\61\2\u0188")
        buf.write("\u0189\79\2\2\u0189\u0191\3\2\2\2\u018a\u018b\78\2\2\u018b")
        buf.write("\u018c\5`\61\2\u018c\u018d\79\2\2\u018d\u0191\3\2\2\2")
        buf.write("\u018e\u018f\78\2\2\u018f\u0191\79\2\2\u0190\u0182\3\2")
        buf.write("\2\2\u0190\u018a\3\2\2\2\u0190\u018e\3\2\2\2\u0191m\3")
        buf.write("\2\2\2\u0192\u0193\7\20\2\2\u0193\u0194\78\2\2\u0194\u0195")
        buf.write("\5p9\2\u0195\u0196\79\2\2\u0196\u0197\5\36\20\2\u0197")
        buf.write("\u01a8\3\2\2\2\u0198\u0199\7\17\2\2\u0199\u019b\78\2\2")
        buf.write("\u019a\u019c\5p9\2\u019b\u019a\3\2\2\2\u019b\u019c\3\2")
        buf.write("\2\2\u019c\u019d\3\2\2\2\u019d\u019f\7\62\2\2\u019e\u01a0")
        buf.write("\5p9\2\u019f\u019e\3\2\2\2\u019f\u01a0\3\2\2\2\u01a0\u01a1")
        buf.write("\3\2\2\2\u01a1\u01a3\7\62\2\2\u01a2\u01a4\5p9\2\u01a3")
        buf.write("\u01a2\3\2\2\2\u01a3\u01a4\3\2\2\2\u01a4\u01a5\3\2\2\2")
        buf.write("\u01a5\u01a6\79\2\2\u01a6\u01a8\5\36\20\2\u01a7\u0192")
        buf.write("\3\2\2\2\u01a7\u0198\3\2\2\2\u01a8o\3\2\2\2\u01a9\u01aa")
        buf.write("\58\35\2\u01aa\u01ab\7;\2\2\u01ab\u01ac\5`\61\2\u01ac")
        buf.write("\u01b2\3\2\2\2\u01ad\u01b2\5`\61\2\u01ae\u01af\7<\2\2")
        buf.write("\u01af\u01b0\7;\2\2\u01b0\u01b2\5\2\2\2\u01b1\u01a9\3")
        buf.write("\2\2\2\u01b1\u01ad\3\2\2\2\u01b1\u01ae\3\2\2\2\u01b2q")
        buf.write("\3\2\2\2%u\u0081\u008a\u0093\u0098\u00aa\u00ac\u00b1\u00be")
        buf.write("\u00c3\u00cc\u00d3\u00d7\u00f0\u0100\u0107\u0113\u011b")
        buf.write("\u0120\u0128\u0130\u0137\u014f\u0158\u0161\u016a\u0171")
        buf.write("\u017d\u0184\u0190\u019b\u019f\u01a3\u01a7\u01b1")
        return buf.getvalue()


class CMLangParser ( Parser ):

    grammarFileName = "CMLang.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'complex'", "'string'", "'bool'", "'?'", 
                     "'input'", "'output'", "'state'", "'flow'", "'parameter'", 
                     "'spring'", "'reservoir'", "'component'", "'for'", 
                     "'while'", "'iterator'", "'!'", "'!='", "'+'", "'-'", 
                     "'/'", "'<'", "'<='", "'=='", "'>'", "'>='", "'*'", 
                     "'^'", "'fread'", "'fwrite'", "'float'", "'bin'", "'int'", 
                     "'max'", "'argmax'", "'min'", "'argmin'", "'e'", "'pi'", 
                     "'sum'", "'norm'", "'gaussian'", "'sigmoid'", "'ceiling'", 
                     "'sigmoid_symmetric'", "'log'", "'log2'", "'random'", 
                     "';'", "':'", "'['", "']'", "'}'", "'{'", "'('", "')'", 
                     "','", "'='" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "INPUT", "OUTPUT", "STATE", "FLOW", "PARAMETER", 
                      "SPRING", "RESERVOIR", "COMPONENT", "FOR", "WHILE", 
                      "ITERATOR", "NOT", "NOTEQ", "ADD", "SUB", "DIV", "LT", 
                      "LEQ", "EQUAL", "GT", "GEQ", "MUL", "POW", "FILE_READ", 
                      "FILE_WRITE", "FLOAT_FUNC", "BINARY_FUNC", "INT_FUNC", 
                      "MAX", "ARGMAX", "MIN", "ARGMIN", "E", "PI", "SUM", 
                      "NORM", "GAUSSIAN", "SIGMOID", "CEILING", "SIG_SYM", 
                      "LOG", "LOG2", "RANDOM", "SEMI", "COLON", "LEFT_BRACK", 
                      "RIGHT_BRACK", "RIGHT_CURLY", "LEFT_CURLY", "LEFT_PAREN", 
                      "RIGHT_PAREN", "COMMA", "ASSIGN", "ID", "WHITESPACE", 
                      "COMMENT", "STRING", "DECIMAL_INTEGER", "OCT_INTEGER", 
                      "HEX_INTEGER", "BIN_INTEGER", "FLOAT_NUMBER", "IMAG_NUMBER" ]

    RULE_number = 0
    RULE_integer = 1
    RULE_val_type = 2
    RULE_program = 3
    RULE_component_list = 4
    RULE_component_definition = 5
    RULE_component_parameters = 6
    RULE_arg_list = 7
    RULE_default_param_value = 8
    RULE_flow_def_index = 9
    RULE_arg = 10
    RULE_parameter_arg_def = 11
    RULE_arg_type = 12
    RULE_component_type = 13
    RULE_component_body = 14
    RULE_statement_list = 15
    RULE_statement = 16
    RULE_primitive = 17
    RULE_data_decl = 18
    RULE_flow_declaration = 19
    RULE_iterator_declaration = 20
    RULE_power = 21
    RULE_iterator = 22
    RULE_flow = 23
    RULE_var_list_flow = 24
    RULE_var_list_flow_tail = 25
    RULE_var_list = 26
    RULE_var = 27
    RULE_var_id = 28
    RULE_id_tail = 29
    RULE_flow_index = 30
    RULE_var_list_tail = 31
    RULE_var_list_iterator = 32
    RULE_component_inst = 33
    RULE_call_param_id = 34
    RULE_comp_param_id = 35
    RULE_comp_param_list = 36
    RULE_comp_param_list_tail = 37
    RULE_call_param_list = 38
    RULE_call_param_list_tail = 39
    RULE_file_function = 40
    RULE_file_operation = 41
    RULE_function = 42
    RULE_predicate = 43
    RULE_logic = 44
    RULE_add_sub = 45
    RULE_mul_div = 46
    RULE_expr = 47
    RULE_logical_expr = 48
    RULE_add_sub_expr = 49
    RULE_factor = 50
    RULE_signed_value = 51
    RULE_atom = 52
    RULE_function_args = 53
    RULE_cond_loop = 54
    RULE_iter_expression = 55

    ruleNames =  [ "number", "integer", "val_type", "program", "component_list", 
                   "component_definition", "component_parameters", "arg_list", 
                   "default_param_value", "flow_def_index", "arg", "parameter_arg_def", 
                   "arg_type", "component_type", "component_body", "statement_list", 
                   "statement", "primitive", "data_decl", "flow_declaration", 
                   "iterator_declaration", "power", "iterator", "flow", 
                   "var_list_flow", "var_list_flow_tail", "var_list", "var", 
                   "var_id", "id_tail", "flow_index", "var_list_tail", "var_list_iterator", 
                   "component_inst", "call_param_id", "comp_param_id", "comp_param_list", 
                   "comp_param_list_tail", "call_param_list", "call_param_list_tail", 
                   "file_function", "file_operation", "function", "predicate", 
                   "logic", "add_sub", "mul_div", "expr", "logical_expr", 
                   "add_sub_expr", "factor", "signed_value", "atom", "function_args", 
                   "cond_loop", "iter_expression" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    INPUT=5
    OUTPUT=6
    STATE=7
    FLOW=8
    PARAMETER=9
    SPRING=10
    RESERVOIR=11
    COMPONENT=12
    FOR=13
    WHILE=14
    ITERATOR=15
    NOT=16
    NOTEQ=17
    ADD=18
    SUB=19
    DIV=20
    LT=21
    LEQ=22
    EQUAL=23
    GT=24
    GEQ=25
    MUL=26
    POW=27
    FILE_READ=28
    FILE_WRITE=29
    FLOAT_FUNC=30
    BINARY_FUNC=31
    INT_FUNC=32
    MAX=33
    ARGMAX=34
    MIN=35
    ARGMIN=36
    E=37
    PI=38
    SUM=39
    NORM=40
    GAUSSIAN=41
    SIGMOID=42
    CEILING=43
    SIG_SYM=44
    LOG=45
    LOG2=46
    RANDOM=47
    SEMI=48
    COLON=49
    LEFT_BRACK=50
    RIGHT_BRACK=51
    RIGHT_CURLY=52
    LEFT_CURLY=53
    LEFT_PAREN=54
    RIGHT_PAREN=55
    COMMA=56
    ASSIGN=57
    ID=58
    WHITESPACE=59
    COMMENT=60
    STRING=61
    DECIMAL_INTEGER=62
    OCT_INTEGER=63
    HEX_INTEGER=64
    BIN_INTEGER=65
    FLOAT_NUMBER=66
    IMAG_NUMBER=67

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class NumberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integer(self):
            return self.getTypedRuleContext(CMLangParser.IntegerContext,0)


        def FLOAT_NUMBER(self):
            return self.getToken(CMLangParser.FLOAT_NUMBER, 0)

        def IMAG_NUMBER(self):
            return self.getToken(CMLangParser.IMAG_NUMBER, 0)

        def getRuleIndex(self):
            return CMLangParser.RULE_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumber" ):
                return visitor.visitNumber(self)
            else:
                return visitor.visitChildren(self)




    def number(self):

        localctx = CMLangParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_number)
        try:
            self.state = 115
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CMLangParser.DECIMAL_INTEGER, CMLangParser.OCT_INTEGER, CMLangParser.HEX_INTEGER, CMLangParser.BIN_INTEGER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 112
                self.integer()
                pass
            elif token in [CMLangParser.FLOAT_NUMBER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 113
                self.match(CMLangParser.FLOAT_NUMBER)
                pass
            elif token in [CMLangParser.IMAG_NUMBER]:
                self.enterOuterAlt(localctx, 3)
                self.state = 114
                self.match(CMLangParser.IMAG_NUMBER)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IntegerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DECIMAL_INTEGER(self):
            return self.getToken(CMLangParser.DECIMAL_INTEGER, 0)

        def OCT_INTEGER(self):
            return self.getToken(CMLangParser.OCT_INTEGER, 0)

        def HEX_INTEGER(self):
            return self.getToken(CMLangParser.HEX_INTEGER, 0)

        def BIN_INTEGER(self):
            return self.getToken(CMLangParser.BIN_INTEGER, 0)

        def getRuleIndex(self):
            return CMLangParser.RULE_integer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInteger" ):
                listener.enterInteger(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInteger" ):
                listener.exitInteger(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInteger" ):
                return visitor.visitInteger(self)
            else:
                return visitor.visitChildren(self)




    def integer(self):

        localctx = CMLangParser.IntegerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_integer)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117
            _la = self._input.LA(1)
            if not(((((_la - 62)) & ~0x3f) == 0 and ((1 << (_la - 62)) & ((1 << (CMLangParser.DECIMAL_INTEGER - 62)) | (1 << (CMLangParser.OCT_INTEGER - 62)) | (1 << (CMLangParser.HEX_INTEGER - 62)) | (1 << (CMLangParser.BIN_INTEGER - 62)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Val_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CMLangParser.RULE_val_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVal_type" ):
                listener.enterVal_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVal_type" ):
                listener.exitVal_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVal_type" ):
                return visitor.visitVal_type(self)
            else:
                return visitor.visitChildren(self)




    def val_type(self):

        localctx = CMLangParser.Val_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_val_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 119
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CMLangParser.T__0) | (1 << CMLangParser.T__1) | (1 << CMLangParser.T__2) | (1 << CMLangParser.FLOAT_FUNC) | (1 << CMLangParser.INT_FUNC))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ProgramContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def component_list(self):
            return self.getTypedRuleContext(CMLangParser.Component_listContext,0)


        def EOF(self):
            return self.getToken(CMLangParser.EOF, 0)

        def getRuleIndex(self):
            return CMLangParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = CMLangParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_program)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 121
            self.component_list()
            self.state = 122
            self.match(CMLangParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Component_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def component_definition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CMLangParser.Component_definitionContext)
            else:
                return self.getTypedRuleContext(CMLangParser.Component_definitionContext,i)


        def getRuleIndex(self):
            return CMLangParser.RULE_component_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComponent_list" ):
                listener.enterComponent_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComponent_list" ):
                listener.exitComponent_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComponent_list" ):
                return visitor.visitComponent_list(self)
            else:
                return visitor.visitChildren(self)




    def component_list(self):

        localctx = CMLangParser.Component_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_component_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 125 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 124
                self.component_definition()
                self.state = 127 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CMLangParser.SPRING) | (1 << CMLangParser.RESERVOIR) | (1 << CMLangParser.COMPONENT))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Component_definitionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def component_type(self):
            return self.getTypedRuleContext(CMLangParser.Component_typeContext,0)


        def ID(self):
            return self.getToken(CMLangParser.ID, 0)

        def component_parameters(self):
            return self.getTypedRuleContext(CMLangParser.Component_parametersContext,0)


        def component_body(self):
            return self.getTypedRuleContext(CMLangParser.Component_bodyContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_component_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComponent_definition" ):
                listener.enterComponent_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComponent_definition" ):
                listener.exitComponent_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComponent_definition" ):
                return visitor.visitComponent_definition(self)
            else:
                return visitor.visitChildren(self)




    def component_definition(self):

        localctx = CMLangParser.Component_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_component_definition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 129
            self.component_type()
            self.state = 130
            self.match(CMLangParser.ID)
            self.state = 131
            self.component_parameters()
            self.state = 132
            self.component_body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Component_parametersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(CMLangParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(CMLangParser.RIGHT_PAREN, 0)

        def arg_list(self):
            return self.getTypedRuleContext(CMLangParser.Arg_listContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_component_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComponent_parameters" ):
                listener.enterComponent_parameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComponent_parameters" ):
                listener.exitComponent_parameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComponent_parameters" ):
                return visitor.visitComponent_parameters(self)
            else:
                return visitor.visitChildren(self)




    def component_parameters(self):

        localctx = CMLangParser.Component_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_component_parameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 134
            self.match(CMLangParser.LEFT_PAREN)
            self.state = 136
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CMLangParser.INPUT) | (1 << CMLangParser.OUTPUT) | (1 << CMLangParser.STATE) | (1 << CMLangParser.PARAMETER))) != 0):
                self.state = 135
                self.arg_list()


            self.state = 138
            self.match(CMLangParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Arg_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CMLangParser.ArgContext)
            else:
                return self.getTypedRuleContext(CMLangParser.ArgContext,i)


        def getRuleIndex(self):
            return CMLangParser.RULE_arg_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArg_list" ):
                listener.enterArg_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArg_list" ):
                listener.exitArg_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArg_list" ):
                return visitor.visitArg_list(self)
            else:
                return visitor.visitChildren(self)




    def arg_list(self):

        localctx = CMLangParser.Arg_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_arg_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 140
            self.arg()
            self.state = 145
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CMLangParser.COMMA:
                self.state = 141
                self.match(CMLangParser.COMMA)
                self.state = 142
                self.arg()
                self.state = 147
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Default_param_valueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(CMLangParser.STRING, 0)

        def number(self):
            return self.getTypedRuleContext(CMLangParser.NumberContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_default_param_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault_param_value" ):
                listener.enterDefault_param_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault_param_value" ):
                listener.exitDefault_param_value(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefault_param_value" ):
                return visitor.visitDefault_param_value(self)
            else:
                return visitor.visitChildren(self)




    def default_param_value(self):

        localctx = CMLangParser.Default_param_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_default_param_value)
        try:
            self.state = 150
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CMLangParser.STRING]:
                self.enterOuterAlt(localctx, 1)
                self.state = 148
                self.match(CMLangParser.STRING)
                pass
            elif token in [CMLangParser.DECIMAL_INTEGER, CMLangParser.OCT_INTEGER, CMLangParser.HEX_INTEGER, CMLangParser.BIN_INTEGER, CMLangParser.FLOAT_NUMBER, CMLangParser.IMAG_NUMBER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 149
                self.number()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Flow_def_indexContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(CMLangParser.ID, 0)

        def getRuleIndex(self):
            return CMLangParser.RULE_flow_def_index

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFlow_def_index" ):
                listener.enterFlow_def_index(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFlow_def_index" ):
                listener.exitFlow_def_index(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFlow_def_index" ):
                return visitor.visitFlow_def_index(self)
            else:
                return visitor.visitChildren(self)




    def flow_def_index(self):

        localctx = CMLangParser.Flow_def_indexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_flow_def_index)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 152
            self.match(CMLangParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ArgContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg_type(self):
            return self.getTypedRuleContext(CMLangParser.Arg_typeContext,0)


        def val_type(self):
            return self.getTypedRuleContext(CMLangParser.Val_typeContext,0)


        def ID(self):
            return self.getToken(CMLangParser.ID, 0)

        def parameter_arg_def(self):
            return self.getTypedRuleContext(CMLangParser.Parameter_arg_defContext,0)


        def LEFT_BRACK(self, i:int=None):
            if i is None:
                return self.getTokens(CMLangParser.LEFT_BRACK)
            else:
                return self.getToken(CMLangParser.LEFT_BRACK, i)

        def RIGHT_BRACK(self, i:int=None):
            if i is None:
                return self.getTokens(CMLangParser.RIGHT_BRACK)
            else:
                return self.getToken(CMLangParser.RIGHT_BRACK, i)

        def flow_def_index(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CMLangParser.Flow_def_indexContext)
            else:
                return self.getTypedRuleContext(CMLangParser.Flow_def_indexContext,i)


        def getRuleIndex(self):
            return CMLangParser.RULE_arg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArg" ):
                listener.enterArg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArg" ):
                listener.exitArg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArg" ):
                return visitor.visitArg(self)
            else:
                return visitor.visitChildren(self)




    def arg(self):

        localctx = CMLangParser.ArgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_arg)
        self._la = 0 # Token type
        try:
            self.state = 170
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 154
                self.arg_type()
                self.state = 155
                self.val_type()
                self.state = 156
                self.match(CMLangParser.ID)
                self.state = 157
                self.parameter_arg_def()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 159
                self.arg_type()
                self.state = 160
                self.val_type()
                self.state = 161
                self.match(CMLangParser.ID)
                self.state = 166 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 162
                    self.match(CMLangParser.LEFT_BRACK)

                    self.state = 163
                    self.flow_def_index()
                    self.state = 164
                    self.match(CMLangParser.RIGHT_BRACK)
                    self.state = 168 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==CMLangParser.LEFT_BRACK):
                        break

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Parameter_arg_defContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def default_param_value(self):
            return self.getTypedRuleContext(CMLangParser.Default_param_valueContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_parameter_arg_def

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter_arg_def" ):
                listener.enterParameter_arg_def(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter_arg_def" ):
                listener.exitParameter_arg_def(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameter_arg_def" ):
                return visitor.visitParameter_arg_def(self)
            else:
                return visitor.visitChildren(self)




    def parameter_arg_def(self):

        localctx = CMLangParser.Parameter_arg_defContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_parameter_arg_def)
        try:
            self.state = 175
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CMLangParser.ASSIGN]:
                self.enterOuterAlt(localctx, 1)
                self.state = 172
                self.match(CMLangParser.ASSIGN)
                self.state = 173
                self.default_param_value()
                pass
            elif token in [CMLangParser.RIGHT_PAREN, CMLangParser.COMMA]:
                self.enterOuterAlt(localctx, 2)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Arg_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INPUT(self):
            return self.getToken(CMLangParser.INPUT, 0)

        def OUTPUT(self):
            return self.getToken(CMLangParser.OUTPUT, 0)

        def STATE(self):
            return self.getToken(CMLangParser.STATE, 0)

        def PARAMETER(self):
            return self.getToken(CMLangParser.PARAMETER, 0)

        def getRuleIndex(self):
            return CMLangParser.RULE_arg_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArg_type" ):
                listener.enterArg_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArg_type" ):
                listener.exitArg_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArg_type" ):
                return visitor.visitArg_type(self)
            else:
                return visitor.visitChildren(self)




    def arg_type(self):

        localctx = CMLangParser.Arg_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_arg_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 177
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CMLangParser.INPUT) | (1 << CMLangParser.OUTPUT) | (1 << CMLangParser.STATE) | (1 << CMLangParser.PARAMETER))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Component_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMPONENT(self):
            return self.getToken(CMLangParser.COMPONENT, 0)

        def RESERVOIR(self):
            return self.getToken(CMLangParser.RESERVOIR, 0)

        def SPRING(self):
            return self.getToken(CMLangParser.SPRING, 0)

        def getRuleIndex(self):
            return CMLangParser.RULE_component_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComponent_type" ):
                listener.enterComponent_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComponent_type" ):
                listener.exitComponent_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComponent_type" ):
                return visitor.visitComponent_type(self)
            else:
                return visitor.visitChildren(self)




    def component_type(self):

        localctx = CMLangParser.Component_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_component_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 179
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CMLangParser.SPRING) | (1 << CMLangParser.RESERVOIR) | (1 << CMLangParser.COMPONENT))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Component_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_CURLY(self):
            return self.getToken(CMLangParser.LEFT_CURLY, 0)

        def statement_list(self):
            return self.getTypedRuleContext(CMLangParser.Statement_listContext,0)


        def RIGHT_CURLY(self):
            return self.getToken(CMLangParser.RIGHT_CURLY, 0)

        def getRuleIndex(self):
            return CMLangParser.RULE_component_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComponent_body" ):
                listener.enterComponent_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComponent_body" ):
                listener.exitComponent_body(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComponent_body" ):
                return visitor.visitComponent_body(self)
            else:
                return visitor.visitChildren(self)




    def component_body(self):

        localctx = CMLangParser.Component_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_component_body)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 181
            self.match(CMLangParser.LEFT_CURLY)
            self.state = 182
            self.statement_list()
            self.state = 183
            self.match(CMLangParser.RIGHT_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Statement_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CMLangParser.StatementContext)
            else:
                return self.getTypedRuleContext(CMLangParser.StatementContext,i)


        def getRuleIndex(self):
            return CMLangParser.RULE_statement_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement_list" ):
                listener.enterStatement_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement_list" ):
                listener.exitStatement_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement_list" ):
                return visitor.visitStatement_list(self)
            else:
                return visitor.visitChildren(self)




    def statement_list(self):

        localctx = CMLangParser.Statement_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_statement_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 186 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 185
                self.statement()
                self.state = 188 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CMLangParser.FLOW) | (1 << CMLangParser.FOR) | (1 << CMLangParser.WHILE) | (1 << CMLangParser.ITERATOR) | (1 << CMLangParser.FILE_READ) | (1 << CMLangParser.FILE_WRITE) | (1 << CMLangParser.ID))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primitive(self):
            return self.getTypedRuleContext(CMLangParser.PrimitiveContext,0)


        def component_inst(self):
            return self.getTypedRuleContext(CMLangParser.Component_instContext,0)


        def cond_loop(self):
            return self.getTypedRuleContext(CMLangParser.Cond_loopContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = CMLangParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_statement)
        try:
            self.state = 193
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 190
                self.primitive()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 191
                self.component_inst()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 192
                self.cond_loop()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PrimitiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def data_decl(self):
            return self.getTypedRuleContext(CMLangParser.Data_declContext,0)


        def SEMI(self):
            return self.getToken(CMLangParser.SEMI, 0)

        def var(self):
            return self.getTypedRuleContext(CMLangParser.VarContext,0)


        def ASSIGN(self):
            return self.getToken(CMLangParser.ASSIGN, 0)

        def expr(self):
            return self.getTypedRuleContext(CMLangParser.ExprContext,0)


        def predicate(self):
            return self.getTypedRuleContext(CMLangParser.PredicateContext,0)


        def file_operation(self):
            return self.getTypedRuleContext(CMLangParser.File_operationContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_primitive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimitive" ):
                listener.enterPrimitive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimitive" ):
                listener.exitPrimitive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimitive" ):
                return visitor.visitPrimitive(self)
            else:
                return visitor.visitChildren(self)




    def primitive(self):

        localctx = CMLangParser.PrimitiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_primitive)
        try:
            self.state = 209
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CMLangParser.FLOW, CMLangParser.ITERATOR]:
                self.enterOuterAlt(localctx, 1)
                self.state = 195
                self.data_decl()
                self.state = 196
                self.match(CMLangParser.SEMI)
                pass
            elif token in [CMLangParser.ID]:
                self.enterOuterAlt(localctx, 2)
                self.state = 198
                self.var()
                self.state = 199
                self.match(CMLangParser.ASSIGN)
                self.state = 202
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
                if la_ == 1:
                    self.state = 200
                    self.expr()
                    pass

                elif la_ == 2:
                    self.state = 201
                    self.predicate()
                    pass


                self.state = 204
                self.match(CMLangParser.SEMI)
                pass
            elif token in [CMLangParser.FILE_READ, CMLangParser.FILE_WRITE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 206
                self.file_operation()
                self.state = 207
                self.match(CMLangParser.SEMI)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Data_declContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def flow_declaration(self):
            return self.getTypedRuleContext(CMLangParser.Flow_declarationContext,0)


        def iterator_declaration(self):
            return self.getTypedRuleContext(CMLangParser.Iterator_declarationContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_data_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterData_decl" ):
                listener.enterData_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitData_decl" ):
                listener.exitData_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitData_decl" ):
                return visitor.visitData_decl(self)
            else:
                return visitor.visitChildren(self)




    def data_decl(self):

        localctx = CMLangParser.Data_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_data_decl)
        try:
            self.state = 213
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CMLangParser.FLOW]:
                self.enterOuterAlt(localctx, 1)
                self.state = 211
                self.flow_declaration()
                pass
            elif token in [CMLangParser.ITERATOR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 212
                self.iterator_declaration()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Flow_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOW(self):
            return self.getToken(CMLangParser.FLOW, 0)

        def val_type(self):
            return self.getTypedRuleContext(CMLangParser.Val_typeContext,0)


        def var_list_flow(self):
            return self.getTypedRuleContext(CMLangParser.Var_list_flowContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_flow_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFlow_declaration" ):
                listener.enterFlow_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFlow_declaration" ):
                listener.exitFlow_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFlow_declaration" ):
                return visitor.visitFlow_declaration(self)
            else:
                return visitor.visitChildren(self)




    def flow_declaration(self):

        localctx = CMLangParser.Flow_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_flow_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 215
            self.match(CMLangParser.FLOW)
            self.state = 216
            self.val_type()
            self.state = 217
            self.var_list_flow()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Iterator_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def iterator(self):
            return self.getTypedRuleContext(CMLangParser.IteratorContext,0)


        def var_list_iterator(self):
            return self.getTypedRuleContext(CMLangParser.Var_list_iteratorContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_iterator_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIterator_declaration" ):
                listener.enterIterator_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIterator_declaration" ):
                listener.exitIterator_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIterator_declaration" ):
                return visitor.visitIterator_declaration(self)
            else:
                return visitor.visitChildren(self)




    def iterator_declaration(self):

        localctx = CMLangParser.Iterator_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_iterator_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 219
            self.iterator()
            self.state = 220
            self.var_list_iterator()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PowerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POW(self):
            return self.getToken(CMLangParser.POW, 0)

        def getRuleIndex(self):
            return CMLangParser.RULE_power

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPower" ):
                listener.enterPower(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPower" ):
                listener.exitPower(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPower" ):
                return visitor.visitPower(self)
            else:
                return visitor.visitChildren(self)




    def power(self):

        localctx = CMLangParser.PowerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_power)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 222
            self.match(CMLangParser.POW)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IteratorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ITERATOR(self):
            return self.getToken(CMLangParser.ITERATOR, 0)

        def getRuleIndex(self):
            return CMLangParser.RULE_iterator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIterator" ):
                listener.enterIterator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIterator" ):
                listener.exitIterator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIterator" ):
                return visitor.visitIterator(self)
            else:
                return visitor.visitChildren(self)




    def iterator(self):

        localctx = CMLangParser.IteratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_iterator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 224
            self.match(CMLangParser.ITERATOR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FlowContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(CMLangParser.ID, 0)

        def LEFT_BRACK(self):
            return self.getToken(CMLangParser.LEFT_BRACK, 0)

        def RIGHT_BRACK(self):
            return self.getToken(CMLangParser.RIGHT_BRACK, 0)

        def id_tail(self):
            return self.getTypedRuleContext(CMLangParser.Id_tailContext,0)


        def flow_index(self):
            return self.getTypedRuleContext(CMLangParser.Flow_indexContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_flow

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFlow" ):
                listener.enterFlow(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFlow" ):
                listener.exitFlow(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFlow" ):
                return visitor.visitFlow(self)
            else:
                return visitor.visitChildren(self)




    def flow(self):

        localctx = CMLangParser.FlowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_flow)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 226
            self.match(CMLangParser.ID)
            self.state = 227
            self.match(CMLangParser.LEFT_BRACK)

            self.state = 228
            self.flow_index()
            self.state = 229
            self.match(CMLangParser.RIGHT_BRACK)
            self.state = 230
            self.id_tail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Var_list_flowContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def flow(self):
            return self.getTypedRuleContext(CMLangParser.FlowContext,0)


        def var_list_flow_tail(self):
            return self.getTypedRuleContext(CMLangParser.Var_list_flow_tailContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_var_list_flow

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_list_flow" ):
                listener.enterVar_list_flow(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_list_flow" ):
                listener.exitVar_list_flow(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVar_list_flow" ):
                return visitor.visitVar_list_flow(self)
            else:
                return visitor.visitChildren(self)




    def var_list_flow(self):

        localctx = CMLangParser.Var_list_flowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_var_list_flow)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 232
            self.flow()
            self.state = 233
            self.var_list_flow_tail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Var_list_flow_tailContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMA(self):
            return self.getToken(CMLangParser.COMMA, 0)

        def var_list_flow(self):
            return self.getTypedRuleContext(CMLangParser.Var_list_flowContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_var_list_flow_tail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_list_flow_tail" ):
                listener.enterVar_list_flow_tail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_list_flow_tail" ):
                listener.exitVar_list_flow_tail(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVar_list_flow_tail" ):
                return visitor.visitVar_list_flow_tail(self)
            else:
                return visitor.visitChildren(self)




    def var_list_flow_tail(self):

        localctx = CMLangParser.Var_list_flow_tailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_var_list_flow_tail)
        try:
            self.state = 238
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CMLangParser.COMMA]:
                self.enterOuterAlt(localctx, 1)
                self.state = 235
                self.match(CMLangParser.COMMA)
                self.state = 236
                self.var_list_flow()
                pass
            elif token in [CMLangParser.SEMI]:
                self.enterOuterAlt(localctx, 2)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Var_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self):
            return self.getTypedRuleContext(CMLangParser.VarContext,0)


        def var_list_tail(self):
            return self.getTypedRuleContext(CMLangParser.Var_list_tailContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_var_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_list" ):
                listener.enterVar_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_list" ):
                listener.exitVar_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVar_list" ):
                return visitor.visitVar_list(self)
            else:
                return visitor.visitChildren(self)




    def var_list(self):

        localctx = CMLangParser.Var_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_var_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 240
            self.var()
            self.state = 241
            self.var_list_tail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VarContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var_id(self):
            return self.getTypedRuleContext(CMLangParser.Var_idContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_var

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar" ):
                listener.enterVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar" ):
                listener.exitVar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVar" ):
                return visitor.visitVar(self)
            else:
                return visitor.visitChildren(self)




    def var(self):

        localctx = CMLangParser.VarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_var)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 243
            self.var_id()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Var_idContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(CMLangParser.ID, 0)

        def id_tail(self):
            return self.getTypedRuleContext(CMLangParser.Id_tailContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_var_id

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_id" ):
                listener.enterVar_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_id" ):
                listener.exitVar_id(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVar_id" ):
                return visitor.visitVar_id(self)
            else:
                return visitor.visitChildren(self)




    def var_id(self):

        localctx = CMLangParser.Var_idContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_var_id)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 245
            self.match(CMLangParser.ID)
            self.state = 246
            self.id_tail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Id_tailContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_BRACK(self):
            return self.getToken(CMLangParser.LEFT_BRACK, 0)

        def RIGHT_BRACK(self):
            return self.getToken(CMLangParser.RIGHT_BRACK, 0)

        def id_tail(self):
            return self.getTypedRuleContext(CMLangParser.Id_tailContext,0)


        def flow_index(self):
            return self.getTypedRuleContext(CMLangParser.Flow_indexContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_id_tail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterId_tail" ):
                listener.enterId_tail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitId_tail" ):
                listener.exitId_tail(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitId_tail" ):
                return visitor.visitId_tail(self)
            else:
                return visitor.visitChildren(self)




    def id_tail(self):

        localctx = CMLangParser.Id_tailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_id_tail)
        try:
            self.state = 254
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CMLangParser.LEFT_BRACK]:
                self.enterOuterAlt(localctx, 1)
                self.state = 248
                self.match(CMLangParser.LEFT_BRACK)

                self.state = 249
                self.flow_index()
                self.state = 250
                self.match(CMLangParser.RIGHT_BRACK)
                self.state = 251
                self.id_tail()
                pass
            elif token in [CMLangParser.T__3, CMLangParser.ADD, CMLangParser.SUB, CMLangParser.DIV, CMLangParser.LT, CMLangParser.LEQ, CMLangParser.EQUAL, CMLangParser.GT, CMLangParser.GEQ, CMLangParser.MUL, CMLangParser.POW, CMLangParser.SEMI, CMLangParser.COLON, CMLangParser.RIGHT_BRACK, CMLangParser.RIGHT_PAREN, CMLangParser.COMMA, CMLangParser.ASSIGN]:
                self.enterOuterAlt(localctx, 2)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Flow_indexContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(CMLangParser.ExprContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_flow_index

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFlow_index" ):
                listener.enterFlow_index(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFlow_index" ):
                listener.exitFlow_index(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFlow_index" ):
                return visitor.visitFlow_index(self)
            else:
                return visitor.visitChildren(self)




    def flow_index(self):

        localctx = CMLangParser.Flow_indexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_flow_index)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 256
            self.expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Var_list_tailContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMA(self):
            return self.getToken(CMLangParser.COMMA, 0)

        def var_list(self):
            return self.getTypedRuleContext(CMLangParser.Var_listContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_var_list_tail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_list_tail" ):
                listener.enterVar_list_tail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_list_tail" ):
                listener.exitVar_list_tail(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVar_list_tail" ):
                return visitor.visitVar_list_tail(self)
            else:
                return visitor.visitChildren(self)




    def var_list_tail(self):

        localctx = CMLangParser.Var_list_tailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_var_list_tail)
        try:
            self.state = 261
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 258
                self.match(CMLangParser.COMMA)
                self.state = 259
                self.var_list()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Var_list_iteratorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(CMLangParser.ID, 0)

        def LEFT_BRACK(self):
            return self.getToken(CMLangParser.LEFT_BRACK, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CMLangParser.ExprContext)
            else:
                return self.getTypedRuleContext(CMLangParser.ExprContext,i)


        def COLON(self):
            return self.getToken(CMLangParser.COLON, 0)

        def RIGHT_BRACK(self):
            return self.getToken(CMLangParser.RIGHT_BRACK, 0)

        def getRuleIndex(self):
            return CMLangParser.RULE_var_list_iterator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_list_iterator" ):
                listener.enterVar_list_iterator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_list_iterator" ):
                listener.exitVar_list_iterator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVar_list_iterator" ):
                return visitor.visitVar_list_iterator(self)
            else:
                return visitor.visitChildren(self)




    def var_list_iterator(self):

        localctx = CMLangParser.Var_list_iteratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_var_list_iterator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 263
            self.match(CMLangParser.ID)
            self.state = 264
            self.match(CMLangParser.LEFT_BRACK)
            self.state = 265
            self.expr()
            self.state = 266
            self.match(CMLangParser.COLON)
            self.state = 267
            self.expr()
            self.state = 268
            self.match(CMLangParser.RIGHT_BRACK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Component_instContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(CMLangParser.ID, 0)

        def LEFT_PAREN(self):
            return self.getToken(CMLangParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(CMLangParser.RIGHT_PAREN, 0)

        def SEMI(self):
            return self.getToken(CMLangParser.SEMI, 0)

        def comp_param_list(self):
            return self.getTypedRuleContext(CMLangParser.Comp_param_listContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_component_inst

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComponent_inst" ):
                listener.enterComponent_inst(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComponent_inst" ):
                listener.exitComponent_inst(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComponent_inst" ):
                return visitor.visitComponent_inst(self)
            else:
                return visitor.visitChildren(self)




    def component_inst(self):

        localctx = CMLangParser.Component_instContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_component_inst)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 270
            self.match(CMLangParser.ID)
            self.state = 271
            self.match(CMLangParser.LEFT_PAREN)
            self.state = 273
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 58)) & ~0x3f) == 0 and ((1 << (_la - 58)) & ((1 << (CMLangParser.ID - 58)) | (1 << (CMLangParser.STRING - 58)) | (1 << (CMLangParser.DECIMAL_INTEGER - 58)) | (1 << (CMLangParser.OCT_INTEGER - 58)) | (1 << (CMLangParser.HEX_INTEGER - 58)) | (1 << (CMLangParser.BIN_INTEGER - 58)) | (1 << (CMLangParser.FLOAT_NUMBER - 58)) | (1 << (CMLangParser.IMAG_NUMBER - 58)))) != 0):
                self.state = 272
                self.comp_param_list()


            self.state = 275
            self.match(CMLangParser.RIGHT_PAREN)
            self.state = 276
            self.match(CMLangParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Call_param_idContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(CMLangParser.ID, 0)

        def number(self):
            return self.getTypedRuleContext(CMLangParser.NumberContext,0)


        def STRING(self):
            return self.getToken(CMLangParser.STRING, 0)

        def getRuleIndex(self):
            return CMLangParser.RULE_call_param_id

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCall_param_id" ):
                listener.enterCall_param_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCall_param_id" ):
                listener.exitCall_param_id(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCall_param_id" ):
                return visitor.visitCall_param_id(self)
            else:
                return visitor.visitChildren(self)




    def call_param_id(self):

        localctx = CMLangParser.Call_param_idContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_call_param_id)
        try:
            self.state = 281
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CMLangParser.ID]:
                self.enterOuterAlt(localctx, 1)
                self.state = 278
                self.match(CMLangParser.ID)
                pass
            elif token in [CMLangParser.DECIMAL_INTEGER, CMLangParser.OCT_INTEGER, CMLangParser.HEX_INTEGER, CMLangParser.BIN_INTEGER, CMLangParser.FLOAT_NUMBER, CMLangParser.IMAG_NUMBER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 279
                self.number()
                pass
            elif token in [CMLangParser.STRING]:
                self.enterOuterAlt(localctx, 3)
                self.state = 280
                self.match(CMLangParser.STRING)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Comp_param_idContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(CMLangParser.ID, 0)

        def number(self):
            return self.getTypedRuleContext(CMLangParser.NumberContext,0)


        def STRING(self):
            return self.getToken(CMLangParser.STRING, 0)

        def getRuleIndex(self):
            return CMLangParser.RULE_comp_param_id

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComp_param_id" ):
                listener.enterComp_param_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComp_param_id" ):
                listener.exitComp_param_id(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComp_param_id" ):
                return visitor.visitComp_param_id(self)
            else:
                return visitor.visitChildren(self)




    def comp_param_id(self):

        localctx = CMLangParser.Comp_param_idContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_comp_param_id)
        try:
            self.state = 286
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CMLangParser.ID]:
                self.enterOuterAlt(localctx, 1)
                self.state = 283
                self.match(CMLangParser.ID)
                pass
            elif token in [CMLangParser.DECIMAL_INTEGER, CMLangParser.OCT_INTEGER, CMLangParser.HEX_INTEGER, CMLangParser.BIN_INTEGER, CMLangParser.FLOAT_NUMBER, CMLangParser.IMAG_NUMBER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 284
                self.number()
                pass
            elif token in [CMLangParser.STRING]:
                self.enterOuterAlt(localctx, 3)
                self.state = 285
                self.match(CMLangParser.STRING)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Comp_param_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def comp_param_id(self):
            return self.getTypedRuleContext(CMLangParser.Comp_param_idContext,0)


        def comp_param_list_tail(self):
            return self.getTypedRuleContext(CMLangParser.Comp_param_list_tailContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_comp_param_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComp_param_list" ):
                listener.enterComp_param_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComp_param_list" ):
                listener.exitComp_param_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComp_param_list" ):
                return visitor.visitComp_param_list(self)
            else:
                return visitor.visitChildren(self)




    def comp_param_list(self):

        localctx = CMLangParser.Comp_param_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_comp_param_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 288
            self.comp_param_id()
            self.state = 289
            self.comp_param_list_tail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Comp_param_list_tailContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMA(self):
            return self.getToken(CMLangParser.COMMA, 0)

        def comp_param_list(self):
            return self.getTypedRuleContext(CMLangParser.Comp_param_listContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_comp_param_list_tail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComp_param_list_tail" ):
                listener.enterComp_param_list_tail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComp_param_list_tail" ):
                listener.exitComp_param_list_tail(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComp_param_list_tail" ):
                return visitor.visitComp_param_list_tail(self)
            else:
                return visitor.visitChildren(self)




    def comp_param_list_tail(self):

        localctx = CMLangParser.Comp_param_list_tailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_comp_param_list_tail)
        try:
            self.state = 294
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CMLangParser.COMMA]:
                self.enterOuterAlt(localctx, 1)
                self.state = 291
                self.match(CMLangParser.COMMA)
                self.state = 292
                self.comp_param_list()
                pass
            elif token in [CMLangParser.RIGHT_PAREN]:
                self.enterOuterAlt(localctx, 2)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Call_param_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def call_param_id(self):
            return self.getTypedRuleContext(CMLangParser.Call_param_idContext,0)


        def call_param_list_tail(self):
            return self.getTypedRuleContext(CMLangParser.Call_param_list_tailContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_call_param_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCall_param_list" ):
                listener.enterCall_param_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCall_param_list" ):
                listener.exitCall_param_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCall_param_list" ):
                return visitor.visitCall_param_list(self)
            else:
                return visitor.visitChildren(self)




    def call_param_list(self):

        localctx = CMLangParser.Call_param_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_call_param_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 296
            self.call_param_id()
            self.state = 297
            self.call_param_list_tail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Call_param_list_tailContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMA(self):
            return self.getToken(CMLangParser.COMMA, 0)

        def call_param_list(self):
            return self.getTypedRuleContext(CMLangParser.Call_param_listContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_call_param_list_tail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCall_param_list_tail" ):
                listener.enterCall_param_list_tail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCall_param_list_tail" ):
                listener.exitCall_param_list_tail(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCall_param_list_tail" ):
                return visitor.visitCall_param_list_tail(self)
            else:
                return visitor.visitChildren(self)




    def call_param_list_tail(self):

        localctx = CMLangParser.Call_param_list_tailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_call_param_list_tail)
        try:
            self.state = 302
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CMLangParser.COMMA]:
                self.enterOuterAlt(localctx, 1)
                self.state = 299
                self.match(CMLangParser.COMMA)
                self.state = 300
                self.call_param_list()
                pass
            elif token in [CMLangParser.RIGHT_PAREN]:
                self.enterOuterAlt(localctx, 2)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class File_functionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FILE_READ(self):
            return self.getToken(CMLangParser.FILE_READ, 0)

        def FILE_WRITE(self):
            return self.getToken(CMLangParser.FILE_WRITE, 0)

        def getRuleIndex(self):
            return CMLangParser.RULE_file_function

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFile_function" ):
                listener.enterFile_function(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFile_function" ):
                listener.exitFile_function(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFile_function" ):
                return visitor.visitFile_function(self)
            else:
                return visitor.visitChildren(self)




    def file_function(self):

        localctx = CMLangParser.File_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_file_function)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 304
            _la = self._input.LA(1)
            if not(_la==CMLangParser.FILE_READ or _la==CMLangParser.FILE_WRITE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class File_operationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def file_function(self):
            return self.getTypedRuleContext(CMLangParser.File_functionContext,0)


        def LEFT_PAREN(self):
            return self.getToken(CMLangParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(CMLangParser.RIGHT_PAREN, 0)

        def call_param_list(self):
            return self.getTypedRuleContext(CMLangParser.Call_param_listContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_file_operation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFile_operation" ):
                listener.enterFile_operation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFile_operation" ):
                listener.exitFile_operation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFile_operation" ):
                return visitor.visitFile_operation(self)
            else:
                return visitor.visitChildren(self)




    def file_operation(self):

        localctx = CMLangParser.File_operationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_file_operation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 306
            self.file_function()
            self.state = 307
            self.match(CMLangParser.LEFT_PAREN)
            self.state = 309
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 58)) & ~0x3f) == 0 and ((1 << (_la - 58)) & ((1 << (CMLangParser.ID - 58)) | (1 << (CMLangParser.STRING - 58)) | (1 << (CMLangParser.DECIMAL_INTEGER - 58)) | (1 << (CMLangParser.OCT_INTEGER - 58)) | (1 << (CMLangParser.HEX_INTEGER - 58)) | (1 << (CMLangParser.BIN_INTEGER - 58)) | (1 << (CMLangParser.FLOAT_NUMBER - 58)) | (1 << (CMLangParser.IMAG_NUMBER - 58)))) != 0):
                self.state = 308
                self.call_param_list()


            self.state = 311
            self.match(CMLangParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PI(self):
            return self.getToken(CMLangParser.PI, 0)

        def SUM(self):
            return self.getToken(CMLangParser.SUM, 0)

        def NORM(self):
            return self.getToken(CMLangParser.NORM, 0)

        def GAUSSIAN(self):
            return self.getToken(CMLangParser.GAUSSIAN, 0)

        def SIGMOID(self):
            return self.getToken(CMLangParser.SIGMOID, 0)

        def SIG_SYM(self):
            return self.getToken(CMLangParser.SIG_SYM, 0)

        def LOG(self):
            return self.getToken(CMLangParser.LOG, 0)

        def LOG2(self):
            return self.getToken(CMLangParser.LOG2, 0)

        def CEILING(self):
            return self.getToken(CMLangParser.CEILING, 0)

        def E(self):
            return self.getToken(CMLangParser.E, 0)

        def FLOAT_FUNC(self):
            return self.getToken(CMLangParser.FLOAT_FUNC, 0)

        def BINARY_FUNC(self):
            return self.getToken(CMLangParser.BINARY_FUNC, 0)

        def INT_FUNC(self):
            return self.getToken(CMLangParser.INT_FUNC, 0)

        def RANDOM(self):
            return self.getToken(CMLangParser.RANDOM, 0)

        def MAX(self):
            return self.getToken(CMLangParser.MAX, 0)

        def ARGMAX(self):
            return self.getToken(CMLangParser.ARGMAX, 0)

        def ARGMIN(self):
            return self.getToken(CMLangParser.ARGMIN, 0)

        def getRuleIndex(self):
            return CMLangParser.RULE_function

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction" ):
                listener.enterFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction" ):
                listener.exitFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunction" ):
                return visitor.visitFunction(self)
            else:
                return visitor.visitChildren(self)




    def function(self):

        localctx = CMLangParser.FunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_function)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 313
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CMLangParser.FLOAT_FUNC) | (1 << CMLangParser.BINARY_FUNC) | (1 << CMLangParser.INT_FUNC) | (1 << CMLangParser.MAX) | (1 << CMLangParser.ARGMAX) | (1 << CMLangParser.ARGMIN) | (1 << CMLangParser.E) | (1 << CMLangParser.PI) | (1 << CMLangParser.SUM) | (1 << CMLangParser.NORM) | (1 << CMLangParser.GAUSSIAN) | (1 << CMLangParser.SIGMOID) | (1 << CMLangParser.CEILING) | (1 << CMLangParser.SIG_SYM) | (1 << CMLangParser.LOG) | (1 << CMLangParser.LOG2) | (1 << CMLangParser.RANDOM))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PredicateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CMLangParser.ExprContext)
            else:
                return self.getTypedRuleContext(CMLangParser.ExprContext,i)


        def COLON(self):
            return self.getToken(CMLangParser.COLON, 0)

        def getRuleIndex(self):
            return CMLangParser.RULE_predicate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicate" ):
                listener.enterPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicate" ):
                listener.exitPredicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicate" ):
                return visitor.visitPredicate(self)
            else:
                return visitor.visitChildren(self)




    def predicate(self):

        localctx = CMLangParser.PredicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_predicate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 315
            self.expr()
            self.state = 316
            self.match(CMLangParser.T__3)
            self.state = 317
            self.expr()
            self.state = 318
            self.match(CMLangParser.COLON)
            self.state = 319
            self.expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LogicContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GEQ(self):
            return self.getToken(CMLangParser.GEQ, 0)

        def GT(self):
            return self.getToken(CMLangParser.GT, 0)

        def EQUAL(self):
            return self.getToken(CMLangParser.EQUAL, 0)

        def LT(self):
            return self.getToken(CMLangParser.LT, 0)

        def LEQ(self):
            return self.getToken(CMLangParser.LEQ, 0)

        def getRuleIndex(self):
            return CMLangParser.RULE_logic

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogic" ):
                listener.enterLogic(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogic" ):
                listener.exitLogic(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogic" ):
                return visitor.visitLogic(self)
            else:
                return visitor.visitChildren(self)




    def logic(self):

        localctx = CMLangParser.LogicContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_logic)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 321
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CMLangParser.LT) | (1 << CMLangParser.LEQ) | (1 << CMLangParser.EQUAL) | (1 << CMLangParser.GT) | (1 << CMLangParser.GEQ))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Add_subContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADD(self):
            return self.getToken(CMLangParser.ADD, 0)

        def SUB(self):
            return self.getToken(CMLangParser.SUB, 0)

        def getRuleIndex(self):
            return CMLangParser.RULE_add_sub

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdd_sub" ):
                listener.enterAdd_sub(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdd_sub" ):
                listener.exitAdd_sub(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdd_sub" ):
                return visitor.visitAdd_sub(self)
            else:
                return visitor.visitChildren(self)




    def add_sub(self):

        localctx = CMLangParser.Add_subContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_add_sub)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 323
            _la = self._input.LA(1)
            if not(_la==CMLangParser.ADD or _la==CMLangParser.SUB):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Mul_divContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MUL(self):
            return self.getToken(CMLangParser.MUL, 0)

        def DIV(self):
            return self.getToken(CMLangParser.DIV, 0)

        def getRuleIndex(self):
            return CMLangParser.RULE_mul_div

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMul_div" ):
                listener.enterMul_div(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMul_div" ):
                listener.exitMul_div(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMul_div" ):
                return visitor.visitMul_div(self)
            else:
                return visitor.visitChildren(self)




    def mul_div(self):

        localctx = CMLangParser.Mul_divContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_mul_div)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 325
            _la = self._input.LA(1)
            if not(_la==CMLangParser.DIV or _la==CMLangParser.MUL):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logical_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CMLangParser.Logical_exprContext)
            else:
                return self.getTypedRuleContext(CMLangParser.Logical_exprContext,i)


        def logic(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CMLangParser.LogicContext)
            else:
                return self.getTypedRuleContext(CMLangParser.LogicContext,i)


        def getRuleIndex(self):
            return CMLangParser.RULE_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr" ):
                listener.enterExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr" ):
                listener.exitExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr" ):
                return visitor.visitExpr(self)
            else:
                return visitor.visitChildren(self)




    def expr(self):

        localctx = CMLangParser.ExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 327
            self.logical_expr()
            self.state = 333
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CMLangParser.LT) | (1 << CMLangParser.LEQ) | (1 << CMLangParser.EQUAL) | (1 << CMLangParser.GT) | (1 << CMLangParser.GEQ))) != 0):
                self.state = 328
                self.logic()
                self.state = 329
                self.logical_expr()
                self.state = 335
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Logical_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def add_sub_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CMLangParser.Add_sub_exprContext)
            else:
                return self.getTypedRuleContext(CMLangParser.Add_sub_exprContext,i)


        def add_sub(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CMLangParser.Add_subContext)
            else:
                return self.getTypedRuleContext(CMLangParser.Add_subContext,i)


        def getRuleIndex(self):
            return CMLangParser.RULE_logical_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogical_expr" ):
                listener.enterLogical_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogical_expr" ):
                listener.exitLogical_expr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogical_expr" ):
                return visitor.visitLogical_expr(self)
            else:
                return visitor.visitChildren(self)




    def logical_expr(self):

        localctx = CMLangParser.Logical_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_logical_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 336
            self.add_sub_expr()
            self.state = 342
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CMLangParser.ADD or _la==CMLangParser.SUB:
                self.state = 337
                self.add_sub()
                self.state = 338
                self.add_sub_expr()
                self.state = 344
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Add_sub_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def factor(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CMLangParser.FactorContext)
            else:
                return self.getTypedRuleContext(CMLangParser.FactorContext,i)


        def mul_div(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CMLangParser.Mul_divContext)
            else:
                return self.getTypedRuleContext(CMLangParser.Mul_divContext,i)


        def getRuleIndex(self):
            return CMLangParser.RULE_add_sub_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdd_sub_expr" ):
                listener.enterAdd_sub_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdd_sub_expr" ):
                listener.exitAdd_sub_expr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdd_sub_expr" ):
                return visitor.visitAdd_sub_expr(self)
            else:
                return visitor.visitChildren(self)




    def add_sub_expr(self):

        localctx = CMLangParser.Add_sub_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_add_sub_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 345
            self.factor()
            self.state = 351
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CMLangParser.DIV or _la==CMLangParser.MUL:
                self.state = 346
                self.mul_div()
                self.state = 347
                self.factor()
                self.state = 353
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FactorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def signed_value(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CMLangParser.Signed_valueContext)
            else:
                return self.getTypedRuleContext(CMLangParser.Signed_valueContext,i)


        def power(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CMLangParser.PowerContext)
            else:
                return self.getTypedRuleContext(CMLangParser.PowerContext,i)


        def getRuleIndex(self):
            return CMLangParser.RULE_factor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactor" ):
                listener.enterFactor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactor" ):
                listener.exitFactor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactor" ):
                return visitor.visitFactor(self)
            else:
                return visitor.visitChildren(self)




    def factor(self):

        localctx = CMLangParser.FactorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_factor)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 354
            self.signed_value()
            self.state = 360
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CMLangParser.POW:
                self.state = 355
                self.power()
                self.state = 356
                self.signed_value()
                self.state = 362
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Signed_valueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def add_sub(self):
            return self.getTypedRuleContext(CMLangParser.Add_subContext,0)


        def signed_value(self):
            return self.getTypedRuleContext(CMLangParser.Signed_valueContext,0)


        def atom(self):
            return self.getTypedRuleContext(CMLangParser.AtomContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_signed_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSigned_value" ):
                listener.enterSigned_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSigned_value" ):
                listener.exitSigned_value(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSigned_value" ):
                return visitor.visitSigned_value(self)
            else:
                return visitor.visitChildren(self)




    def signed_value(self):

        localctx = CMLangParser.Signed_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_signed_value)
        try:
            self.state = 367
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CMLangParser.ADD, CMLangParser.SUB]:
                self.enterOuterAlt(localctx, 1)
                self.state = 363
                self.add_sub()
                self.state = 364
                self.signed_value()
                pass
            elif token in [CMLangParser.FILE_READ, CMLangParser.FILE_WRITE, CMLangParser.FLOAT_FUNC, CMLangParser.BINARY_FUNC, CMLangParser.INT_FUNC, CMLangParser.MAX, CMLangParser.ARGMAX, CMLangParser.ARGMIN, CMLangParser.E, CMLangParser.PI, CMLangParser.SUM, CMLangParser.NORM, CMLangParser.GAUSSIAN, CMLangParser.SIGMOID, CMLangParser.CEILING, CMLangParser.SIG_SYM, CMLangParser.LOG, CMLangParser.LOG2, CMLangParser.RANDOM, CMLangParser.LEFT_PAREN, CMLangParser.ID, CMLangParser.DECIMAL_INTEGER, CMLangParser.OCT_INTEGER, CMLangParser.HEX_INTEGER, CMLangParser.BIN_INTEGER, CMLangParser.FLOAT_NUMBER, CMLangParser.IMAG_NUMBER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 366
                self.atom()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AtomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def number(self):
            return self.getTypedRuleContext(CMLangParser.NumberContext,0)


        def var(self):
            return self.getTypedRuleContext(CMLangParser.VarContext,0)


        def file_operation(self):
            return self.getTypedRuleContext(CMLangParser.File_operationContext,0)


        def function(self):
            return self.getTypedRuleContext(CMLangParser.FunctionContext,0)


        def function_args(self):
            return self.getTypedRuleContext(CMLangParser.Function_argsContext,0)


        def LEFT_PAREN(self):
            return self.getToken(CMLangParser.LEFT_PAREN, 0)

        def expr(self):
            return self.getTypedRuleContext(CMLangParser.ExprContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(CMLangParser.RIGHT_PAREN, 0)

        def getRuleIndex(self):
            return CMLangParser.RULE_atom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom" ):
                listener.enterAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom" ):
                listener.exitAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtom" ):
                return visitor.visitAtom(self)
            else:
                return visitor.visitChildren(self)




    def atom(self):

        localctx = CMLangParser.AtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_atom)
        try:
            self.state = 379
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CMLangParser.DECIMAL_INTEGER, CMLangParser.OCT_INTEGER, CMLangParser.HEX_INTEGER, CMLangParser.BIN_INTEGER, CMLangParser.FLOAT_NUMBER, CMLangParser.IMAG_NUMBER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 369
                self.number()
                pass
            elif token in [CMLangParser.ID]:
                self.enterOuterAlt(localctx, 2)
                self.state = 370
                self.var()
                pass
            elif token in [CMLangParser.FILE_READ, CMLangParser.FILE_WRITE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 371
                self.file_operation()
                pass
            elif token in [CMLangParser.FLOAT_FUNC, CMLangParser.BINARY_FUNC, CMLangParser.INT_FUNC, CMLangParser.MAX, CMLangParser.ARGMAX, CMLangParser.ARGMIN, CMLangParser.E, CMLangParser.PI, CMLangParser.SUM, CMLangParser.NORM, CMLangParser.GAUSSIAN, CMLangParser.SIGMOID, CMLangParser.CEILING, CMLangParser.SIG_SYM, CMLangParser.LOG, CMLangParser.LOG2, CMLangParser.RANDOM]:
                self.enterOuterAlt(localctx, 4)
                self.state = 372
                self.function()
                self.state = 373
                self.function_args()
                pass
            elif token in [CMLangParser.LEFT_PAREN]:
                self.enterOuterAlt(localctx, 5)
                self.state = 375
                self.match(CMLangParser.LEFT_PAREN)
                self.state = 376
                self.expr()
                self.state = 377
                self.match(CMLangParser.RIGHT_PAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Function_argsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(CMLangParser.LEFT_PAREN, 0)

        def expr(self):
            return self.getTypedRuleContext(CMLangParser.ExprContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(CMLangParser.RIGHT_PAREN, 0)

        def LEFT_BRACK(self, i:int=None):
            if i is None:
                return self.getTokens(CMLangParser.LEFT_BRACK)
            else:
                return self.getToken(CMLangParser.LEFT_BRACK, i)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(CMLangParser.ID)
            else:
                return self.getToken(CMLangParser.ID, i)

        def RIGHT_BRACK(self, i:int=None):
            if i is None:
                return self.getTokens(CMLangParser.RIGHT_BRACK)
            else:
                return self.getToken(CMLangParser.RIGHT_BRACK, i)

        def getRuleIndex(self):
            return CMLangParser.RULE_function_args

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_args" ):
                listener.enterFunction_args(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_args" ):
                listener.exitFunction_args(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunction_args" ):
                return visitor.visitFunction_args(self)
            else:
                return visitor.visitChildren(self)




    def function_args(self):

        localctx = CMLangParser.Function_argsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_function_args)
        self._la = 0 # Token type
        try:
            self.state = 398
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 384 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 381
                    self.match(CMLangParser.LEFT_BRACK)
                    self.state = 382
                    self.match(CMLangParser.ID)
                    self.state = 383
                    self.match(CMLangParser.RIGHT_BRACK)
                    self.state = 386 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==CMLangParser.LEFT_BRACK):
                        break

                self.state = 388
                self.match(CMLangParser.LEFT_PAREN)
                self.state = 389
                self.expr()
                self.state = 390
                self.match(CMLangParser.RIGHT_PAREN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 392
                self.match(CMLangParser.LEFT_PAREN)
                self.state = 393
                self.expr()
                self.state = 394
                self.match(CMLangParser.RIGHT_PAREN)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 396
                self.match(CMLangParser.LEFT_PAREN)
                self.state = 397
                self.match(CMLangParser.RIGHT_PAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Cond_loopContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(CMLangParser.WHILE, 0)

        def LEFT_PAREN(self):
            return self.getToken(CMLangParser.LEFT_PAREN, 0)

        def iter_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CMLangParser.Iter_expressionContext)
            else:
                return self.getTypedRuleContext(CMLangParser.Iter_expressionContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(CMLangParser.RIGHT_PAREN, 0)

        def component_body(self):
            return self.getTypedRuleContext(CMLangParser.Component_bodyContext,0)


        def FOR(self):
            return self.getToken(CMLangParser.FOR, 0)

        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(CMLangParser.SEMI)
            else:
                return self.getToken(CMLangParser.SEMI, i)

        def getRuleIndex(self):
            return CMLangParser.RULE_cond_loop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond_loop" ):
                listener.enterCond_loop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond_loop" ):
                listener.exitCond_loop(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond_loop" ):
                return visitor.visitCond_loop(self)
            else:
                return visitor.visitChildren(self)




    def cond_loop(self):

        localctx = CMLangParser.Cond_loopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_cond_loop)
        self._la = 0 # Token type
        try:
            self.state = 421
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CMLangParser.WHILE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 400
                self.match(CMLangParser.WHILE)
                self.state = 401
                self.match(CMLangParser.LEFT_PAREN)
                self.state = 402
                self.iter_expression()
                self.state = 403
                self.match(CMLangParser.RIGHT_PAREN)
                self.state = 404
                self.component_body()
                pass
            elif token in [CMLangParser.FOR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 406
                self.match(CMLangParser.FOR)
                self.state = 407
                self.match(CMLangParser.LEFT_PAREN)
                self.state = 409
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 18)) & ~0x3f) == 0 and ((1 << (_la - 18)) & ((1 << (CMLangParser.ADD - 18)) | (1 << (CMLangParser.SUB - 18)) | (1 << (CMLangParser.FILE_READ - 18)) | (1 << (CMLangParser.FILE_WRITE - 18)) | (1 << (CMLangParser.FLOAT_FUNC - 18)) | (1 << (CMLangParser.BINARY_FUNC - 18)) | (1 << (CMLangParser.INT_FUNC - 18)) | (1 << (CMLangParser.MAX - 18)) | (1 << (CMLangParser.ARGMAX - 18)) | (1 << (CMLangParser.ARGMIN - 18)) | (1 << (CMLangParser.E - 18)) | (1 << (CMLangParser.PI - 18)) | (1 << (CMLangParser.SUM - 18)) | (1 << (CMLangParser.NORM - 18)) | (1 << (CMLangParser.GAUSSIAN - 18)) | (1 << (CMLangParser.SIGMOID - 18)) | (1 << (CMLangParser.CEILING - 18)) | (1 << (CMLangParser.SIG_SYM - 18)) | (1 << (CMLangParser.LOG - 18)) | (1 << (CMLangParser.LOG2 - 18)) | (1 << (CMLangParser.RANDOM - 18)) | (1 << (CMLangParser.LEFT_PAREN - 18)) | (1 << (CMLangParser.ID - 18)) | (1 << (CMLangParser.DECIMAL_INTEGER - 18)) | (1 << (CMLangParser.OCT_INTEGER - 18)) | (1 << (CMLangParser.HEX_INTEGER - 18)) | (1 << (CMLangParser.BIN_INTEGER - 18)) | (1 << (CMLangParser.FLOAT_NUMBER - 18)) | (1 << (CMLangParser.IMAG_NUMBER - 18)))) != 0):
                    self.state = 408
                    self.iter_expression()


                self.state = 411
                self.match(CMLangParser.SEMI)
                self.state = 413
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 18)) & ~0x3f) == 0 and ((1 << (_la - 18)) & ((1 << (CMLangParser.ADD - 18)) | (1 << (CMLangParser.SUB - 18)) | (1 << (CMLangParser.FILE_READ - 18)) | (1 << (CMLangParser.FILE_WRITE - 18)) | (1 << (CMLangParser.FLOAT_FUNC - 18)) | (1 << (CMLangParser.BINARY_FUNC - 18)) | (1 << (CMLangParser.INT_FUNC - 18)) | (1 << (CMLangParser.MAX - 18)) | (1 << (CMLangParser.ARGMAX - 18)) | (1 << (CMLangParser.ARGMIN - 18)) | (1 << (CMLangParser.E - 18)) | (1 << (CMLangParser.PI - 18)) | (1 << (CMLangParser.SUM - 18)) | (1 << (CMLangParser.NORM - 18)) | (1 << (CMLangParser.GAUSSIAN - 18)) | (1 << (CMLangParser.SIGMOID - 18)) | (1 << (CMLangParser.CEILING - 18)) | (1 << (CMLangParser.SIG_SYM - 18)) | (1 << (CMLangParser.LOG - 18)) | (1 << (CMLangParser.LOG2 - 18)) | (1 << (CMLangParser.RANDOM - 18)) | (1 << (CMLangParser.LEFT_PAREN - 18)) | (1 << (CMLangParser.ID - 18)) | (1 << (CMLangParser.DECIMAL_INTEGER - 18)) | (1 << (CMLangParser.OCT_INTEGER - 18)) | (1 << (CMLangParser.HEX_INTEGER - 18)) | (1 << (CMLangParser.BIN_INTEGER - 18)) | (1 << (CMLangParser.FLOAT_NUMBER - 18)) | (1 << (CMLangParser.IMAG_NUMBER - 18)))) != 0):
                    self.state = 412
                    self.iter_expression()


                self.state = 415
                self.match(CMLangParser.SEMI)
                self.state = 417
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 18)) & ~0x3f) == 0 and ((1 << (_la - 18)) & ((1 << (CMLangParser.ADD - 18)) | (1 << (CMLangParser.SUB - 18)) | (1 << (CMLangParser.FILE_READ - 18)) | (1 << (CMLangParser.FILE_WRITE - 18)) | (1 << (CMLangParser.FLOAT_FUNC - 18)) | (1 << (CMLangParser.BINARY_FUNC - 18)) | (1 << (CMLangParser.INT_FUNC - 18)) | (1 << (CMLangParser.MAX - 18)) | (1 << (CMLangParser.ARGMAX - 18)) | (1 << (CMLangParser.ARGMIN - 18)) | (1 << (CMLangParser.E - 18)) | (1 << (CMLangParser.PI - 18)) | (1 << (CMLangParser.SUM - 18)) | (1 << (CMLangParser.NORM - 18)) | (1 << (CMLangParser.GAUSSIAN - 18)) | (1 << (CMLangParser.SIGMOID - 18)) | (1 << (CMLangParser.CEILING - 18)) | (1 << (CMLangParser.SIG_SYM - 18)) | (1 << (CMLangParser.LOG - 18)) | (1 << (CMLangParser.LOG2 - 18)) | (1 << (CMLangParser.RANDOM - 18)) | (1 << (CMLangParser.LEFT_PAREN - 18)) | (1 << (CMLangParser.ID - 18)) | (1 << (CMLangParser.DECIMAL_INTEGER - 18)) | (1 << (CMLangParser.OCT_INTEGER - 18)) | (1 << (CMLangParser.HEX_INTEGER - 18)) | (1 << (CMLangParser.BIN_INTEGER - 18)) | (1 << (CMLangParser.FLOAT_NUMBER - 18)) | (1 << (CMLangParser.IMAG_NUMBER - 18)))) != 0):
                    self.state = 416
                    self.iter_expression()


                self.state = 419
                self.match(CMLangParser.RIGHT_PAREN)
                self.state = 420
                self.component_body()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Iter_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self):
            return self.getTypedRuleContext(CMLangParser.VarContext,0)


        def ASSIGN(self):
            return self.getToken(CMLangParser.ASSIGN, 0)

        def expr(self):
            return self.getTypedRuleContext(CMLangParser.ExprContext,0)


        def ID(self):
            return self.getToken(CMLangParser.ID, 0)

        def number(self):
            return self.getTypedRuleContext(CMLangParser.NumberContext,0)


        def getRuleIndex(self):
            return CMLangParser.RULE_iter_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIter_expression" ):
                listener.enterIter_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIter_expression" ):
                listener.exitIter_expression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIter_expression" ):
                return visitor.visitIter_expression(self)
            else:
                return visitor.visitChildren(self)




    def iter_expression(self):

        localctx = CMLangParser.Iter_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_iter_expression)
        try:
            self.state = 431
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 423
                self.var()
                self.state = 424
                self.match(CMLangParser.ASSIGN)
                self.state = 425
                self.expr()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 427
                self.expr()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 428
                self.match(CMLangParser.ID)
                self.state = 429
                self.match(CMLangParser.ASSIGN)
                self.state = 430
                self.number()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





